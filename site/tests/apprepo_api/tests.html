<html>
<head>
  <title>App Repo API Tests</title>
  <script type="text/javascript" src="doctestjs/doctest.js"></script>
  <link rel="stylesheet" type="text/css" href="doctestjs/doctest.css" />
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style type="text/css" media="screen">
      iframe { display: none; }
  </style>
</head>
<body id="testingBody">
<h2> App Repo API Tests </h2>

<p>
  These API tests run in a local environment provided by a test
  server.  There are multiple local bound ports which coincide with
  different running apps.  By including /servers.js from the test
  server, window.SERVERS is populated with a map of server names
  (directory names) to URL where that app can be accessed.
</p>

<div>
  <button onclick="doctest()" type="button">Test all</button>
  <pre id="doctestOutput"></pre>
</div>

<h3>Verify Testing Environment</h3>

First let's ensure that the testing environment is sane...
<pre class="doctest">
$ var dirs = [];
> for (var k in SERVERS) dirs.push(k);
> dirs.sort();
[
  "_primary",
  "bad_content_type",
  "basic_app",
  "json_syntax_error",
  "missing_required_field",
  "no_delegated_install",
  "no_mgmt_api_off_repo_origin"
]
</pre>

<h3>Clear All Apps</h3>

Delete all applications and then verify that list() yields no apps.

<pre class="doctest">
$ var finished = false;
$ navigator.apps.mgmt.list(function(m) {
>  var total = 0;
>  for (var k in m) if (m.hasOwnProperty(k)) total++;
>  finished = (total === 0);
>  for (var k in m) {
>    if (!m.hasOwnProperty(k)) continue;
>    navigator.apps.mgmt.remove(k, function(r) {
>      finished = (--total === 0);
>    });
>  }
> });
$ wait(function() { return finished; });
$ finished = false;
$ navigator.apps.mgmt.list(Spy('apps.mgmt.list', {wait: true}));
apps.mgmt.list({})
</pre>

<h3>Install a basic application</h3>

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['basic_app'] + "/manifest.webapp",
>    onsuccess: Spy('apps.install', {wait: true, ignoreThis: true})
>   });
apps.install(true)
$ navigator.apps.mgmt.list(Spy('apps.mgmt.list', {wait: true, wrapArgs: true}));
apps.mgmt.list({
  http://127.0.0.1:...: {
    install_time: ...,
    install_url: "http://127.0.0.1:...",
    manifest: {
      default_locale: "en",
      installs_allowed_from: ["*"],
      name: "Super Crazy Basic App"
    },
    origin: "http://127.0.0.1:..."
  }
})
</pre>

<h3>Re-install that application with a different manifest</h3>

this should be considered an "upgrade", because we may not have
two manifests per origin.

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['basic_app'] + "/manifest2.webapp",
>    onsuccess: Spy('apps.install', {wait: true, ignoreThis: true})
>   });
apps.install(true)
$ navigator.apps.mgmt.list(Spy('apps.mgmt.list', {wait: true, wrapArgs: true}));
apps.mgmt.list({
  http://127.0.0.1:...: {
    install_time: ...,
    install_url: "http://127.0.0.1:...",
    manifest: {
      default_locale: "en",
      installs_allowed_from: ["*"],
      name: "Wild and Crazy Basic App"
    },
    origin: "http://127.0.0.1:..."
  }
})
</pre>

<h3>We installed it, getInstalledBy should return it.</h3>

<pre class="doctest">
$ navigator.apps.getInstalledBy(Spy('apps.getInstalledBy', {wait: true, ignoreThis: true}));
apps.getInstalledBy([
  {
    install_time: ...,
    install_url: "http://127.0.0.1:...",
    manifest: {default_locale: "en", installs_allowed_from: ["*"], name: "Wild and Crazy Basic App"},
    origin: "http://127.0.0.1:..."
  }
])
</pre>

<h3>getInstalled should not.</h3>

<pre class="doctest">
$ navigator.apps.getInstalled(Spy('apps.getInstalled', {wait: true, ignoreThis: true}));
apps.getInstalled([])
</pre>

<h3>Installation of an app with a syntax error in manifest</h3>

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['json_syntax_error'] + "/manifest.webapp",
>    onsuccess: Spy('apps.install.success', {wait: false, ignoreThis: true}),
>    onerror: Spy('apps.install.error', {wait: true, ignoreThis: true})
>   });
apps.install.error({code: "manifestParseError", message: "couldn't parse manifest JSON from http://127.0.0.1:.../manifest.webapp"})
</pre>

<h3>Installation of an app with a malformed manifest (missing key)</h3>

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['missing_required_field'] + "/manifest.webapp",
>    onsuccess: Spy('apps.install.success', {wait: false, ignoreThis: true}),
>    onerror: Spy('apps.install.error', {wait: true, ignoreThis: true})
>   });
apps.install.error({code: "invalidManifest", message: "couldn't validate your manifest: missing \"name\" property"})
</pre>

<h3>Installation of an app without required HTTP Content-Type</h3>

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['bad_content_type'] + "/manifest.json",
>    onsuccess: Spy('apps.install.success', {wait: false, ignoreThis: true}),
>    onerror: Spy('apps.install.error', {wait: true, ignoreThis: true})
>   });
apps.install.error({
  code: "invalidManifest",
  message: "application manifests must be of Content-Type \"application/x-web-app-manifest+json\""
})
</pre>

<h3>Installation of an app without delegated installation permissions</h3>

<pre class="doctest">
$ navigator.apps.install(
>   {url: SERVERS['no_delegated_install'] + "/manifest.webapp",
>    onsuccess: Spy('apps.install.success', {wait: false, ignoreThis: true}),
>    onerror: Spy('apps.install.error', {wait: true, ignoreThis: true})
>   });
apps.install.error({code: "permissionDenied", message: "origin 'http://127.0.0.1:...' may not install this app"})
</pre>

<h3>Verify mgmt permissions don't work off repo origin</h3>

NOTE:  This is a rather tricky test:  We'll programatically embed an iframe from
a non-repo origin and load web content from that origin.  The content
(<tt>no_mgmt_api_off_repo_origin/include.html</tt>) uses jschannel to allow us
to programmatically drive it running queries against the test app repo from
off domain.

<pre class="doctest">
$ // first let's add an iframe with the child to the document */
> var iframe = document.createElement("iframe");
> iframe.src = SERVERS['no_mgmt_api_off_repo_origin'] + "/include.html";
> document.body.appendChild(iframe);
> // next, let's connect to him over a jschannel
> var chan = Channel.build({
>    window: iframe.contentWindow,
>    scope: "test",
>    origin: "*"
> });
> // a utility function to automatically build up proper jschan.call args:
> function buildJSChanArgs(name) {
>   return { method: name,
>            success: Spy('success', {wait: false, ignoreThis: true}), 
>            error: Spy('error', {wait: true, ignoreThis: true}) };
> }
> // now let's queue up a message requesting him to call the 'launch' mgmt function
> chan.call(buildJSChanArgs("launch"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
$ chan.call(buildJSChanArgs("loadState"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
$ chan.call(buildJSChanArgs("loginStatus"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
$ chan.call(buildJSChanArgs("list"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
$ chan.call(buildJSChanArgs("remove"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
$ chan.call(buildJSChanArgs("saveState"));
error("permissionDenied", "to access open web apps management apis, you must be on the same domain as the application repostiory")
</pre>

  <button onclick="doctest()" type="button">Test all</button>

</body>
<script type="text/javascript" src="/servers.js"></script>
<script type="text/javascript" src="/jsapi/include.js"></script>
<script type="text/javascript" src="/js/jschannel.js"></script>
<script type="text/javascript">
  navigator.apps.setRepoOrigin(SERVERS['_primary']);
</script>
</html>
